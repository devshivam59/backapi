const mockPriceService = require('../services/mockPriceService');

// In-memory storage for simplicity
let watchlists = [
  {
    id: 'default-watchlist',
    name: 'My Watchlist',
    instruments: []
  }
];

let zerodhaConfig = {
  apiKey: 'n9fp8kfh1lcbqnt8',
  apiSecret: '4j9bekkl72yo7wv8h34jtl7mhw9gnvf9',
  accessToken: null,
  isConnected: false
};

// Auto token generation function
const generateAutoAccessToken = () => {
  // For demo purposes, generate a mock token
  // In real implementation, this would use Zerodha's API
  const timestamp = Date.now();
  const mockToken = `auto_token_${timestamp}_${Math.random().toString(36).substr(2, 9)}`;
  
  console.log('Auto-generating access token:', mockToken);
  
  zerodhaConfig.accessToken = mockToken;
  zerodhaConfig.isConnected = true;
  
  return {
    success: true,
    accessToken: mockToken,
    message: 'Access token generated automatically using API credentials'
  };
};

// Controller functions
const initializeZerodha = async (req, res) => {
  try {
    console.log('Initializing Zerodha with auto token generation...');
    
    const result = generateAutoAccessToken();
    
    res.json({
      success: true,
      message: 'Zerodha initialized successfully with auto-generated token',
      data: {
        apiKey: zerodhaConfig.apiKey,
        accessToken: result.accessToken,
        isConnected: true,
        autoGenerated: true
      }
    });
  } catch (error) {
    console.error('Error initializing Zerodha:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to initialize Zerodha',
      error: error.message
    });
  }
};

const getMarketStatus = (req, res) => {
  try {
    const now = new Date();
    const hour = now.getHours();
    const day = now.getDay();
    
    // Market hours: 9:15 AM to 3:30 PM, Monday to Friday
    const isMarketOpen = (day >= 1 && day <= 5) && (hour >= 9 && hour < 15);
    
    res.json({
      success: true,
      data: {
        isOpen: isMarketOpen,
        connectionType: isMarketOpen ? 'WebSocket' : 'REST API',
        timestamp: now.toISOString()
      }
    });
  } catch (error) {
    console.error('Error getting market status:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get market status',
      error: error.message
    });
  }
};

const getWatchlists = (req, res) => {
  try {
    res.json({
      success: true,
      data: watchlists
    });
  } catch (error) {
    console.error('Error getting watchlists:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get watchlists',
      error: error.message
    });
  }
};

const createWatchlist = (req, res) => {
  try {
    const { name } = req.body;
    
    if (!name) {
      return res.status(400).json({
        success: false,
        message: 'Watchlist name is required'
      });
    }
    
    const newWatchlist = {
      id: `watchlist-${Date.now()}`,
      name,
      instruments: []
    };
    
    watchlists.push(newWatchlist);
    
    res.json({
      success: true,
      message: 'Watchlist created successfully',
      data: newWatchlist
    });
  } catch (error) {
    console.error('Error creating watchlist:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create watchlist',
      error: error.message
    });
  }
};

const getWatchlist = async (req, res) => {
  try {
    const { id } = req.params;
    
    const watchlist = watchlists.find(w => w.id === id);
    if (!watchlist) {
      return res.status(404).json({
        success: false,
        message: 'Watchlist not found'
      });
    }
    
    // Add live prices to instruments
    const instrumentsWithPrices = watchlist.instruments.map(instrument => {
      const livePrice = mockPriceService.getPrice(instrument.tradingsymbol || instrument.symbol);
      return {
        ...instrument,
        livePrice
      };
    });
    
    res.json({
      success: true,
      data: {
        ...watchlist,
        instruments: instrumentsWithPrices
      }
    });
  } catch (error) {
    console.error('Error getting watchlist:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get watchlist',
      error: error.message
    });
  }
};

const addInstrumentToWatchlist = (req, res) => {
  try {
    const { id } = req.params;
    const instrument = req.body;
    
    const watchlist = watchlists.find(w => w.id === id);
    if (!watchlist) {
      return res.status(404).json({
        success: false,
        message: 'Watchlist not found'
      });
    }
    
    // Check if instrument already exists
    const exists = watchlist.instruments.some(
      i => i.instrument_token === instrument.instrument_token
    );
    
    if (exists) {
      return res.status(400).json({
        success: false,
        message: 'Instrument already exists in watchlist'
      });
    }
    
    watchlist.instruments.push(instrument);
    
    res.json({
      success: true,
      message: 'Instrument added to watchlist successfully',
      data: watchlist
    });
  } catch (error) {
    console.error('Error adding instrument to watchlist:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to add instrument to watchlist',
      error: error.message
    });
  }
};

const removeInstrumentFromWatchlist = (req, res) => {
  try {
    const { id, instrumentToken } = req.params;
    
    const watchlist = watchlists.find(w => w.id === id);
    if (!watchlist) {
      return res.status(404).json({
        success: false,
        message: 'Watchlist not found'
      });
    }
    
    const initialLength = watchlist.instruments.length;
    watchlist.instruments = watchlist.instruments.filter(
      i => i.instrument_token !== instrumentToken
    );
    
    if (watchlist.instruments.length === initialLength) {
      return res.status(404).json({
        success: false,
        message: 'Instrument not found in watchlist'
      });
    }
    
    res.json({
      success: true,
      message: 'Instrument removed from watchlist successfully',
      data: watchlist
    });
  } catch (error) {
    console.error('Error removing instrument from watchlist:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to remove instrument from watchlist',
      error: error.message
    });
  }
};

const deleteWatchlist = (req, res) => {
  try {
    const { id } = req.params;
    
    const initialLength = watchlists.length;
    watchlists = watchlists.filter(w => w.id !== id);
    
    if (watchlists.length === initialLength) {
      return res.status(404).json({
        success: false,
        message: 'Watchlist not found'
      });
    }
    
    res.json({
      success: true,
      message: 'Watchlist deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting watchlist:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete watchlist',
      error: error.message
    });
  }
};

// Export all functions
module.exports = {
  initializeZerodha,
  getMarketStatus,
  getWatchlists,
  createWatchlist,
  getWatchlist,
  addInstrumentToWatchlist,
  removeInstrumentFromWatchlist,
  deleteWatchlist
};
